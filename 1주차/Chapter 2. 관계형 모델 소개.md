
## 2.1 관계형 데이터베이스의 구조

### 2.1.1 RDB, 테이블
* 관계형 데이터베이스는 **테이블의 모임**으로 구성
* 각 테이블은 고유한 이름 보유
* 일반적으로 테이블의 각 행은 일련의 값 사이의 **관계**를 표현
* 테이블 개념은 이러한 관계들의 모임이므로, **릴레이션**이라는 수학적 개념과 밀접한 관련 존재

### 2.1.2 튜플, 릴레이션, 속성 그리고 도메인
* 수학적 의미의 튜플은 간단한 값의 나열 혹은 값의 리스트
* n개의 값에 대한 관계는 수학적으로 값의 **n-튜플**로 표현
* 릴레이션은 테이블을 의미하는 단어로 사용
* 튜플은 테이블의 행을 의미
* 속성은 테이블의 열을 의미
* **릴레이션 인스턴스**는 행의 특정 집합을 포함하고 있는 릴레이션의 특정 인스턴스를 지칭
* 릴레이션은 **튜플의 집합**, 튜플의 순서는 상관 X
* 릴레이션의 각 속성은 허가된 값의 집합을 가지고 있으며, 그것을 **도메인** 이라고 지칭
* 모든 릴레이션 r 에 대해서 r 의 모든 속성의 도메인은 **원자적**
* 널 값은 알려지지 않거나 존재하지 않는 값을 의미하는 특별한 값
* 저자의 주장은 널 값은 제거하는 것이 좋다고 한다.

## 2.2 데이터베이스 스키마

### 2.2.1 스키마,  인스턴스 차이
* DB 의 논리적 설계를 **데이터베이스 스키마**
* 어느 한 순간의 데이터베이스에 저장된 데이터의 스냅샷을 **데이터베이스 인스턴스**
* **릴레이션 인스턴스**의 개념은 프로그래밍 언어의 변수 값에 해당
* **릴레이션 스키마**는 프로그래밍 언어의 타입 정의에 해당
* 릴레이션 스키마 그리고 릴레이션 인스턴스를 같은 이름으로 지칭 가능

## 2.3 키
* 튜플의 속성 값은 그 튜플을 **유일하게 식별**할 수 있어야 한다.

### 2.3.1 Super Key
* 한 릴레이션에서 튜플을 **유일하게 식별**할 수 있도록 하는 **1개 이상의 속성 집합**
* 릴레이션 r 의 스키마에 존재하는 속성들의 집합을 R 이라고 하고, R 의 부분집합 K 가 있을 때, K 가 만약 수퍼 키라면 K 를 포함한 어떠한 집합도 수퍼 키가 된다.

### 2.3.2 Candidate Key
* 수퍼 키의 부분집합이 수퍼 키가 아닌 경우가 존재
* 그리고 수퍼 키 집합 중 최소한의 수퍼 키를 **후보 키**
* 예를 들어 특정 릴레이션에 { ID }, { name, dept_name } 가 수퍼 키라고 했을 때, { ID } 만으로 후보 키를 이루므로, 최소한의 수퍼 키는 { ID } 가 되어 후보 키의 정의에 따라서 ID 속성 하나만 후보 키

### 2.3.3 Primary Key
* DB 설계자에 의해 선택된 후보 키를 지칭할 때는 그것을 **주 키(Primary Key)** 라 지칭
* 릴레이션의 어떠한 튜플도 동시에 키 속성(주 키, 후보 키, 수퍼 키)에 대해 같은 값을 보유 불가
* 키 지정은 모델링하는 실 세계 제약조건을 나타내기 때문에, 주 키는 **주 키 제약조건**을 갖게 된다.
* 주 키를 선택할 때, 해당 속성이 절대로 변하지 않거나 변화가 매우 드문 키를 선택해야 한다.

### 2.3.4 Foreign Key Constraint
* 릴레이션 스키마 r1 의 속성 A, 다른 릴레이션 스키마 r2 의 주 키 B 가 있다고 가정
* 모든 DB 인스턴스에 대해 r1 에 존재하는 튜플의 A 값이 r2 에 있는 특정 튜플의 B 값으로 반드시 나와야 하는 것이 **외래 키 제약조건**
* 외래 키 제약 조건에서 참조되는 속성은 참조된 릴레이션의 주 키여야 한다.

### 2.3.5 참조 무결성 제약 조건
* "참조하는 릴레이션의 어떤 튜플의 특정 속성에 출현한 값이 참조되는 릴레이션에서 적어도 하나의 튜플의 특정 속성으로 출현해야 한다" 가 **참조 무결성 제약 조건 정의**
* 참조된 속성이 참조된 릴레이션의 주 키를 구성 해야 한다는 조건을 완화한 것
* 즉, 해당 조건은 참조된 것이 주 키가 아니어도 가능하다는 것이 위의 의미
* 따라서 외래 키 제약 조건은 참조 무결성 제약 조건의 특별한 경우
* 오늘 날 DBMS 는 외래 키 제약 조건만을 지원

### 2.4 스키마 다이어그램
* 릴레이션은 네모 상자로 표현
* 속성은 네모 상자 안에 나열
* 릴레이션 이름은 네모 상자 위에 표현
* 주 키는 밑 줄로 그어서 표현
* 외래 키 종속성은 참조하는 릴레이션의 외래 키 속성으로 부터 참조된 릴레이션의 주 키에 화살표로 표현

### 2.5 관계형 질의어
* 사용자가 DB로 부터 정보를 요청할 때 사용하는 언어를 **질의어**
* 종류는 다음 3가지가 있다.
* **명령형 질의어**는 사용자가 원하는 결과를 계산하기 위해 DB 에 일련의 연산을 수행하도록 명령, 계산 과정에서 갱신되는 상태 변수가 존재
* **함수형 질의어**에서 계산은 DB 에 있는 데이터 또는 다른 함수 결과에 대해서 동작하는 함수의 실행으로 표현, 함수 부작용 X, 프로그램 상태 갱신 X
* **선언형 질의어**는  사용자가 원하는 정보만 기술, 원하는 정보는 전형적으로 수학적 논리 형태로 기술, 방식은 DBMS 의 일

### 2.6 관계 대수
* 한 개 또는 두 개 릴레이션을 입력, 그 결과로 새로운 릴레이션을 생성하는 연산들의 집합으로 구성
* **관계 대수**는 함수형 언어
* 단항 연산
	* 선택
	* 추출
	* 재명명
* 이항 연산
	* 카티시안 곱
	* 차집합
	* ...
* SQL 질의어의 기본을 구성하지만, DBMS 는 사용자가 직접 관계 대수 형태로 질의 작성 X
* 릴레이션은 튜플들의 집합이고, 중복된 튜플을 포함할 수 없다고 했으나 DBMS 는 특별한 제한 조건이 없고 중복 튜플을 포함할 수 있다.
* 그러나 정규 관계 대수는 집합에 대한 정의를 따르기 때문에 중복은 제거된다.

### 2.6.1 선택 연산
* 특정 릴레이션에 대해서 주어진 술어를 만족하는 **튜플을 선택**
* SQL `SELECT` 에서 WHERE 절을 넣은 연산과 동일
* $\sigma$ <sub>attribute</sub> = <sub>attribute domain</sub> (relation name)
* attribute 란에는 술어(predicate) 가 들어가며, $=, \neq, <, \leq, >, \geq$ 등의 기호 사용 가능
* 해당 기호들 $\wedge, \vee, \neg$ 등의 연결 기호도 사용 가능
* 연산 예시
	* $\sigma$ <sub>salary>9000</sub> (instructor)
	* $\sigma$ <sub>dept_name = "Physics"  ∧ salary > 9000</sub>  (instructor)
 
### 2.6.2 추출 연산
* 입력 릴레이션의 어떤 속성을 삭제한 후, 나머지 모두를 결과 릴레이션으로 돌려주는 단항 연산
* $\Pi$ <sub>attributes</sub> (relation)
* attributes 에는 속성 이름만 !
* 단, 아래와 같은 속성에 대해서 연산자를 적용하는 것이 가능
* SQL `SELECT` 에서 특정 컬럼만 선택하는 연산과 동일
* 연산 예시
	* $\Pi$ <sub>ID, name, salary</sub> (relation)
	* $\Pi$ <sub>ID, name, salary / 12</sub> (relation)

### 2.6.3 혼합 관계 연산
* 추출 연산 매개 변수로 릴레이션을 평가하는 표현식이 올 수 있다.
* 관계 대수 연산은 **관계 대수식**으로 구성될 수 있다.
* 해당 대수식의 구성은 산술 연산($+, - , *, \div$)을 산술 표현식으로 구성하는 것과 같다.
* 연산 예시
	* $\Pi$ ($\sigma$ <sub>dept_name = "Physics"</sub>  (instructor))

### 2.6.4 카티션 곱 연산
* 릴레이션의 결합된 정보를 얻기 위해서 사용
* $r1 \times r2$ 으로 표현
* 집합의 카티션 곱과 다른 부분은 집합은 결과로 튜플 $t1, t2$ 를 각각 쌍 $(t1, t2)$ 을 만들지만, 관계 대수는 하나의 튜플로 만든다.
* 같은 이름의 속성이 있을 수 있기 때문에, 릴레이션 이름을 붙인다.
* 단, 하나의 릴레이션에만 나타나는 속성의 경우에는 이름을 붙이는 것을 사용하진 않는다.
* 연산의 결과는 행렬의 곱과 유사한데, **r1 의 하나의 튜플에 r2 에 존재하는 모든 튜플을 각각 하나의 튜플로 만든다.**
* $r1$ 에는 n<sub>1</sub> 개의 튜플이 존재하고 $r2$ 에는 n<sub>2</sub> 개의 튜플이 존재할 때, $r1 \times r2$ 의 결과로 나오는 릴레이션의 튜플 개수는 $n_1 * n_2$ 개 이다.

### 2.6.5 조인 연산
* **조인 연산**은 선택 연산과 카티션 곱 연산을 하나로 합친 것
* 릴레이션 r, s 가 있고, 스키마 $R \cup S$ 을 $\theta$ 로 가정
* 표현은 $r ⋈_θ s = \sigma_θ (r \times s)$ 이다.
* 연산 예시
	* $\sigma$<sub>instructor.ID = teaches.ID</sub> (instructor $\times$ teaches) $\Leftrightarrow$ 
	* instructor $⋈$ <sub>instructor.ID = teaches.ID</sub> teaches

### 2.6.6 집합 연산
#### 합집합
* 합집합 표현 $R \cup S$
* 조건
	* 두 릴레이션의 속성 수가 같아야 한다.(속성 수를 **인수(arity)**라 한다.)
	* 릴레이션 r 의 i 번째 속성의 도메인과 릴레이션 s 의 i 번째 속성의 도메인이 같아야 한다.
* 이러한 릴레이션을 **호환 가능한 릴레이션**
* 연산 예시
	* $\Pi$<sub>course_id</sub>($\sigma$<sub>semester = "Fall" ∧ year = 2017 </sub>(section)) $\cup$ 
	  $\Pi$<sub>course_id</sub>($\sigma$<sub>semester = "Spring" ∧ year = 2018 </sub>(section))

#### 교집합
* 합집합 표현 $R \cap S$
* 조건
	* 합집합과 마찬가지로 서로 호환 가능한 릴레이션 간에 이루어 진다.
* 연산 예시
	* $\Pi$<sub>course_id</sub>($\sigma$<sub>semester = "Fall" ∧ year = 2017 </sub>(section)) $\cap$ 
	  $\Pi$<sub>course_id</sub>($\sigma$<sub>semester = "Spring" ∧ year = 2018 </sub>(section))

#### 차집합
* 한 릴레이션에는 속하나 다른 릴레이션에는 속하지 않는 튜플을 찾는 연산
* 차집합 표현 $R - S$
* $\Pi$<sub>course_id</sub>($\sigma$<sub>semester = "Fall" ∧ year = 2017 </sub>(section)) $-$ 
  $\Pi$<sub>course_id</sub>($\sigma$<sub>semester = "Spring" ∧ year = 2018 </sub>(section))

### 2.6.7 배정 연산
* 프로그래밍 언어에 대입과 유사
* 배정 연산의 표현 $\leftarrow$
* 해당 연산은 항상 일시적 릴레이션 변수로 되어 있어야 한다.
* 배정의 결과는 어떤 릴레이션에도 영향 X
* 해당 릴레이션 변수는 이어지는 표현식에 사용 가능
* 연산 예시
	* courses_fall_2017 $\leftarrow$ $\Pi$<sub>course_id</sub>($\sigma$<sub>semester = "Fall" ∧ year = 2017 </sub>(section))
	  courses_spring_2018 $\leftarrow$ $\Pi$<sub>course_id</sub>($\sigma$<sub>semester = "Spring" ∧ year = 2018 </sub>(section)
	  courses_fall_2017 $\cap$ courses_spring_2018

### 2.6.8 재명명 연산
* 관계 대수식 결과에 해당 연산을 적용해서 이름 부여 가능
* 재명명 연산 표현 $\rho$ 
* SQL 에서 AS 연산자와 유사

### 2.6.9 동등 질의
* 두 질의가 달라도 동일한 결과를 출력하면 두 질의는 동등하다.
* 연산 예시
	* $\sigma$ <sub>dept_name = "Physics"</sub>  (instructor $⋈$ <sub>instructor.ID = teaches.ID</sub> teaches) $\Leftrightarrow$ 
	  ($\sigma$ <sub>dept_name = "Physics"</sub>(instructor)) $⋈$ <sub>instructor.ID = teaches.ID</sub> teaches